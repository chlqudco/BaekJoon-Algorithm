```

fun insertAndInit() {

}

fun calculate() {

}

fun main() = with(System.`in`.bufferedReader()) {
    insertAndInit()

    calculate()
}

```

- 시간 제한이 1초 일 때
	- N <= 500   -> O(N^3) 까지 가능
	- N <= 2,000 -> O(N^2) 까지 가능
	- N <= 100,000  -> O(NlogN) 까지 가능
	- N <= 10,000,000  -> O(N) 까지 가능

- int형 변수 10,000,000개 --> 40MB

- 그리디
	- 당장 눈앞의 이익에만 집중
	- 특정 조건으로 정렬해두면 구현이 쉬워지는 경우가 많다.
	- 많은 그리디는 동적플밍으로 풀수 있다.

	- 그리디의 두가지 속성
		- 탐욕적 선택 속성 : 각 단계에서 우리가 선택한 답을 포함하는 최적해가 있는지
		- 최적 부분 구조 : 각 단계에서 최적선택을 했을때 전체 최적해를 구할 수 있는지

- 이진탐색
	- 코드 간단하니까 쳐 외우셈, start, end, mid
	- 말도 안되게 큰 수를 보면 이진 탐색을 의심해야함
	- 뭐를 start, end, mid로 잡을지만 파악하면 문제가 너무 간단해짐

- 세그먼트 트리
	- 여러개의 데이터의 특정 범위 합을 빠르게 구함
	- 구간 내의 최소값과 최대값도 아주 빠르게 찾을수 있음

- DP
	- base, return, recur case
	- 메모이제이션 : 배열을 마련해두고, 한번 계산한 값을 저장해 뒀다가 재활용하는 기법
	- 푸는 방법
		- 재귀로 풀수 있는 완전탐색 알고리즘 만들기
		- 중복된 부분을 없애도록 메모이제이션 사용
	- 메모이제이션은 탑다운에서만 쓰는 말, 바텀업은 DP테이블이라고 부름
	- DP와 분할정복의 차이
		- 둘다 큰 문제를 작게 나누고 있음
		- DP는 나눈 문제들이 서로 영향을 끼침
  
- 다익스트라
	- 특정 노드에서의 최다 경로 구하는 알고리즘
	- 음의 간선 없어야 함
	- 그리디 알고리즘임 (매번 가장 cost가 적은 길을 선택함으로)
